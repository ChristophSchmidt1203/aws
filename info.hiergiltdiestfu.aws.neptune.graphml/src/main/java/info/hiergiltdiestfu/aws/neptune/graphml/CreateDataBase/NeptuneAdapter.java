package info.hiergiltdiestfu.aws.neptune.graphml.createdatabase;

import java.io.Writer;
import java.time.LocalDateTime;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.apache.tinkerpop.gremlin.driver.Cluster;
import org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;
import org.apache.tinkerpop.gremlin.driver.ser.Serializers;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
import org.apache.tinkerpop.gremlin.process.traversal.step.util.WithOptions;
import org.apache.tinkerpop.gremlin.structure.Graph;
import org.apache.tinkerpop.gremlin.structure.T;
import org.apache.tinkerpop.gremlin.structure.util.empty.EmptyGraph;
import org.graphdrawing.graphml.xmlns.*;
import org.springframework.web.util.HtmlUtils;

/**
 * This class creates a backup file of a graph database, in XML format. This
 * file allows to import a new database without data loss.
 * 
 * @author LUNOACK
 *
 */
public class NeptuneAdapter {

	/**
	 * These are for the Marschall of the Graph Values.
	 */
	private static final ObjectFactory o = new ObjectFactory();
	private static final JAXBContext ctx;
	private static final Marshaller mrshl;
	private String port;
	private String host;

	/**
	 * These are the Edge-Information which are extracted from the Database
	 */
	/**
	 * Edge-ID
	 */
	private static final String ID = "ID";
	/**
	 * The Vertex-Source of the Edge
	 */
	private static final String IN = "IN";
	/**
	 * The Vertex-Target of the Edge
	 */
	private static final String OUT = "OUT";
	/**
	 * The Edge Properties
	 */
	private static final String PROP = "PROP";
	/**
	 * The Edge-Labe√∂
	 */
	private static final String LABEL = "LABEL";

	public NeptuneAdapter(String p, String h) {
		this.port = p;
		this.host = h;
	}

	static {
		try {
			ctx = JAXBContext.newInstance(ObjectFactory.class);
			mrshl = ctx.createMarshaller();
			mrshl.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
		} catch (JAXBException e) {
			throw new RuntimeException(e);
		}
	}
	private static final String SOURCE = new Object().toString(), TARGET = new Object().toString();

	/**
	 * Creates a XMl-String with the values of the Database.
	 * 
	 * @param out
	 * @return
	 * @throws Exception
	 */
	public String serialize(Writer out) throws Exception {
		final long start = System.currentTimeMillis();
		final var objects = convert();
		final var desc = objects.getValue().getDesc();
		objects.getValue().setDesc("Exported from AWS Neptune");

		mrshl.marshal(objects, out);

		out.append(String.format(
				"\n<!-- %s -->\n<!-- Took %d millis -->\n<!-- Generated by %s -->\n<!-- Generated on %s -->\n", desc,
				((System.currentTimeMillis() - start)), "info.hiergiltdiestfu.aws.neptune.graphml Adapter",
				LocalDateTime.now().toString()));

		return out.toString();

	}

	/**
	 * Converts the Data in a XML Format.
	 * 
	 * @return
	 */
	public JAXBElement<GraphmlType> convert() {
		final var extract = extract();
//		System.err.println(extract);
		final var root = o.createGraphmlType();
		root.setDesc(String.format("%d nodes, %d edges, %d properties", extract.getNodes().size(),
				extract.getEdges().size(), (extract.getNodeProperties().size() + extract.getEdgeProperties().size())));

		extract.getNodeProperties().remove("id");
		extract.getEdgeProperties().remove("id");

		extract.getNodeProperties().entrySet().stream().map(entry -> buildPropKey(entry, KeyForType.NODE))
				.forEach(root.getKey()::add);
		extract.getEdgeProperties().entrySet().stream()
				.filter(pre -> !(SOURCE.equals(pre.getKey()) || TARGET.equals(pre.getKey())))
				.map(entry -> buildPropKey(entry, KeyForType.EDGE)).forEach(root.getKey()::add);

		final var graph = o.createGraphType();
		root.getGraphOrData().add(graph);

		graph.setEdgedefault(GraphEdgedefaultType.DIRECTED);
		graph.getDataOrNodeOrEdge(); // nodes, edges

		extract.getNodes().stream().map(this::buildNode).forEach(graph.getDataOrNodeOrEdge()::add);
		extract.getEdges().stream().map(this::buildEdge).forEach(graph.getDataOrNodeOrEdge()::add);

		return o.createGraphml(root);
	}

	/**
	 * Creates the Objects of the Edges.
	 * 
	 * @param entry
	 * @return
	 */
	private EdgeType buildEdge(Map<Object, Object> entry) {
		EdgeType result = o.createEdgeType();
		result.setId(String.valueOf(entry.remove(T.id)));
		result.setSource(String.valueOf(entry.remove(SOURCE)));
		result.setTarget(String.valueOf(entry.remove(TARGET)));

		entry.entrySet().stream().map(this::buildData).forEach(result.getData()::add);

		return result;
	}

	/**
	 * Creates a Object if the Vertices.
	 * 
	 * @param entry
	 * @return
	 */
	private NodeType buildNode(Map<Object, Object> entry) {
		NodeType result = o.createNodeType();
		result.setId(String.valueOf(entry.remove(T.id)));

		entry.entrySet().stream().map(this::buildData).forEach(result.getDataOrPort()::add);

		return result;
	}

	private DataType buildData(Entry<Object, Object> entry) {
		final DataType result = o.createDataType();

		result.setKey(HtmlUtils.htmlEscape(String.valueOf(entry.getKey())));
		var value = entry.getValue();
		if (value instanceof List && ((List<?>) value).size() == 1)
			value = ((List<?>) value).get(0);
		result.setContent(HtmlUtils.htmlEscape(String.valueOf(value)));

		return result;
	}

	/**
	 * Creates the KeyType of the Database.
	 * 
	 * @param entry
	 * @param forT
	 * @return
	 */
	private KeyType buildPropKey(Entry<String, Object> entry, KeyForType forT) {
		final var ekey = entry.getKey();
		final var eval = entry.getValue();

		final KeyType k = o.createKeyType();
		k.setId(HtmlUtils.htmlEscape(ekey));
		k.setFor(forT);
		// attr.name?
		// attr.type
		return k;
	}

	private GraphTraversalSource g = null;

	/**
	 * Extracts the Data from the GRaph Database.
	 * 
	 * @return
	 */
	public ExtractedGraph extract() {
		this.g = setup();

		var eg = extractGraph(getG());
		try {
			getG().close();
		} catch (Exception t) {
			System.err.println(t);
		}

		eg = analyzeAttributes(eg);

		return eg;

	}

	/**
	 * In this function the Edge-Data and Vertex-Data is requested from the
	 * Database. And then written on a List.
	 * 
	 * @param g
	 * @return
	 */
	private static ExtractedGraph extractGraph(GraphTraversalSource g) {
		final var vortices = g.V().valueMap().with(WithOptions.tokens);
		final var edges = g.E().project(ID, IN, OUT, PROP, LABEL).by(__.id()).by(__.inV().union(__.id()).unfold())
				.by(__.outV().union(__.id()).unfold()).by(__.valueMap()).by(__.label().fold());

		List<Map<Object, Object>> vertList = new LinkedList<>();
		while (vortices.hasNext()) {
			vertList.add(vortices.next());
		}

		List<Map<Object, Object>> edgeList = new LinkedList<>();
		while (edges.hasNext()) {
			var e = edges.next();
			Map<Object, Object> result = new HashMap<>();
			result.put(SOURCE, e.get(IN));
			result.put(TARGET, e.get(OUT));
			result.put(T.id, e.get(ID));
			result.put(T.label, e.get(LABEL));
			var prop = (Map<Object, Object>) e.get(PROP);
			for (Map.Entry<Object, Object> entry : prop.entrySet()) {
				result.put(entry.getKey(), entry.getValue());
			}
			edgeList.add(result);
		}
		return new ExtractedGraph(vertList, edgeList);

	}

	/**
	 * Adds the Properies of each Node and Edge.
	 * 
	 * @param eg
	 * @return
	 */
	private static ExtractedGraph analyzeAttributes(ExtractedGraph eg) {
		final Map<String, Object> nodeProps = initProps(eg.getNodes()), edgeProps = initProps(eg.getEdges());

		fillProps(nodeProps, eg.getNodes());
		fillProps(edgeProps, eg.getEdges());

		eg.setVertexProperties(nodeProps);
		eg.setEdgeProperties(edgeProps);

		return eg;
	}

	private static void fillProps(Map<String, Object> output, List<Map<Object, Object>> input) {
		input.parallelStream().flatMap(m -> m.entrySet().stream()).filter(e -> !output.containsKey(e.getKey()))
				.forEach(f -> output.put(f.getKey().toString(), f.getValue().getClass()));
	}

	private static Map<String, Object> initProps(List<Map<Object, Object>> list) {
		if (list.isEmpty()) {
			return Collections.emptyMap();
		} else {
			return new ConcurrentHashMap<>(list.get(0).size() * 3);
		}
	}

	/**
	 * Creates a Connection to a Database.
	 * 
	 * @return
	 */
	private GraphTraversalSource setup() {

		Cluster.Builder builder = Cluster.build().addContactPoint(host).port(Integer.parseInt(port))
				// .enableSsl(true).keyCertChainFile("resources/aws/SFSRootCAG2.pem")
				.maxInProcessPerConnection(32).maxSimultaneousUsagePerConnection(32).maxContentLength(4 * 1024 * 1024)
				.serializer(Serializers.GRAPHBINARY_V1D0);

		final Cluster cluster = builder.create();

		/**
		 * For Testing the Graph
		 *
		 * /* final TinkerGraph graph = TinkerFactory.createGratefulDead();
		 * 
		 * return graph.traversal();
		 */
		Graph g = EmptyGraph.instance();

		GraphTraversalSource graph = g.traversal().withRemote(DriverRemoteConnection.using(cluster));

		return graph;
	}

	public GraphTraversalSource getG() {
		return g;
	}

	public void setG(GraphTraversalSource g) {
		this.g = g;
	}
}
