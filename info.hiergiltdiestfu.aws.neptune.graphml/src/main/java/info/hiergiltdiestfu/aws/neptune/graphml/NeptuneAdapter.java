package info.hiergiltdiestfu.aws.neptune.graphml;

import static org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource.traversal;

import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.Writer;
import java.time.LocalDateTime;
import java.util.*;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.apache.tinkerpop.gremlin.driver.Cluster;
import org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;
import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
import org.apache.tinkerpop.gremlin.process.traversal.step.util.WithOptions;
import org.apache.tinkerpop.gremlin.structure.T;
import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerFactory;
import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph;
import org.graphdrawing.graphml.xmlns.*;
import org.springframework.web.util.HtmlUtils;

public class NeptuneAdapter {

	private static final ObjectFactory o = new ObjectFactory();
	private static final JAXBContext ctx;
	private static final Marshaller mrshl;
	static {
		try {
			ctx = JAXBContext.newInstance(ObjectFactory.class);
			mrshl = ctx.createMarshaller();
			mrshl.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
		} catch (JAXBException e) {
			throw new RuntimeException(e);
		}
	}
	private static final String SOURCE = new Object().toString(), TARGET = new Object().toString();

	public static void main(String[] args) throws Throwable {
		new NeptuneAdapter().serialize(new BufferedWriter(new OutputStreamWriter(System.out), 64_000));
	}

	public String serialize(Writer out) throws Exception {
		final long start = System.currentTimeMillis();
		final var objects = convert();
		final var desc = objects.getValue().getDesc();
		objects.getValue().setDesc("Exported from AWS Neptune");

		mrshl.marshal(objects, out);

		out.append(String.format(
				"\n<!-- %s -->\n<!-- Took %d millis -->\n<!-- Generated by %s -->\n<!-- Generated on %s -->\n", desc,
				((System.currentTimeMillis() - start)), "info.hiergiltdiestfu.aws.neptune.graphml Adapter",
				LocalDateTime.now().toString()));
		
		return out.toString(); 

	}

	public JAXBElement<GraphmlType> convert() {
		final var extract = extract();
//		System.err.println(extract);
		final var root = o.createGraphmlType();
		root.setDesc(String.format("%d nodes, %d edges, %d properties", extract.getNodes().size(),
				extract.getEdges().size(), (extract.getNodeProperties().size() + extract.getEdgeProperties().size())));

		extract.getNodeProperties().remove("id");
		extract.getEdgeProperties().remove("id");

		extract.getNodeProperties().entrySet().stream().map(entry -> buildPropKey(entry, KeyForType.NODE))
				.forEach(root.getKey()::add);
		extract.getEdgeProperties().entrySet().stream()
				.filter(pre -> !(SOURCE.equals(pre.getKey()) || TARGET.equals(pre.getKey())))
				.map(entry -> buildPropKey(entry, KeyForType.EDGE)).forEach(root.getKey()::add);

		final var graph = o.createGraphType();
		root.getGraphOrData().add(graph);

		graph.setEdgedefault(GraphEdgedefaultType.DIRECTED);
		graph.getDataOrNodeOrEdge(); // nodes, edges

		extract.getNodes().stream().map(this::buildNode).forEach(graph.getDataOrNodeOrEdge()::add);
		extract.getEdges().stream().map(this::buildEdge).forEach(graph.getDataOrNodeOrEdge()::add);

		return o.createGraphml(root);
	}

	private EdgeType buildEdge(Map<Object, Object> entry) {
		EdgeType result = o.createEdgeType();
		result.setId(String.valueOf(entry.remove(T.id)));
		result.setSource(String.valueOf(entry.remove(SOURCE)));
		result.setTarget(String.valueOf(entry.remove(TARGET)));

		entry.entrySet().stream().map(this::buildData).forEach(result.getData()::add);

		return result;
	}

	private NodeType buildNode(Map<Object, Object> entry) {
		NodeType result = o.createNodeType();
		result.setId(String.valueOf(entry.remove(T.id)));

		entry.entrySet().stream().map(this::buildData).forEach(result.getDataOrPort()::add);

		return result;
	}

	private DataType buildData(Entry<Object, Object> entry) {
		final DataType result = o.createDataType();

		result.setKey(HtmlUtils.htmlEscape(String.valueOf(entry.getKey())));
		var value = entry.getValue();
		if (value instanceof List && ((List<?>) value).size() == 1)
			value = ((List<?>) value).get(0);
		result.setContent(HtmlUtils.htmlEscape(String.valueOf(value)));

		return result;
	}

	private KeyType buildPropKey(Entry<String, Object> entry, KeyForType forT) {
		final var ekey = entry.getKey();
		final var eval = entry.getValue();

		final KeyType k = o.createKeyType();
		k.setId(HtmlUtils.htmlEscape(ekey));
		k.setFor(forT);
		// attr.name?
		// attr.type
		return k;
	}
	GraphTraversalSource g = null;
	
	public ExtractedGraph extract() {
		g = setup();

		var eg = extractGraph(g);
		try {
			g.close();
		} catch (Exception t) {
			System.err.println(t);
		}

		eg = analyzeAttributes(eg);

		return eg;

	}

	private static ExtractedGraph extractGraph(GraphTraversalSource g) {

		final var vortices = g.V().valueMap().with(WithOptions.tokens);
		final var edges = g.E();// .valueMap().with(WithOptions.tokens);

		List<Map<Object, Object>> vertList = new LinkedList<>();
		while (vortices.hasNext()) {
			vertList.add(vortices.next());
		}
		List<Map<Object, Object>> edgeList = new LinkedList<>();
		while (edges.hasNext()) {
			Map<Object, Object> result = new HashMap<>();
			final var next = edges.next();
			final var properties = next.properties();
			result.put(SOURCE, next.outVertex().id());
			result.put(TARGET, next.inVertex().id());
			result.put(T.id, next.id());
			result.put(T.label, next.label());
			while (properties.hasNext()) {
				final var prop = properties.next();
				result.put(prop.key(), prop.value());
			}
			edgeList.add(result);
		}

		return new ExtractedGraph(vertList, edgeList);

	}

	private static ExtractedGraph analyzeAttributes(ExtractedGraph eg) {
		final Map<String, Object> nodeProps = initProps(eg.getNodes()), edgeProps = initProps(eg.getEdges());

		fillProps(nodeProps, eg.getNodes());
		fillProps(edgeProps, eg.getEdges());

		eg.setVertexProperties(nodeProps);
		eg.setEdgeProperties(edgeProps);

		return eg;
	}

	private static void fillProps(Map<String, Object> output, List<Map<Object, Object>> input) {
		input.parallelStream().flatMap(m -> m.entrySet().stream()).filter(e -> !output.containsKey(e.getKey()))
				.forEach(f -> output.put(f.getKey().toString(), f.getValue().getClass()));
	}

	private static Map<String, Object> initProps(List<Map<Object, Object>> list) {
		if (list.isEmpty()) {
			return Collections.emptyMap();
		} else {
			return new ConcurrentHashMap<>(list.get(0).size() * 3);
		}
	}

	private static GraphTraversalSource setup() {
		/*
persistence.neptune.contactpoint=localhost
persistence.neptune.contactport=8182
persistence.neptune.certchainfile=resources/aws/SFSRootCAG2.pem
		 */
		
		Cluster.Builder builder = Cluster.build();
		builder.addContactPoint("localhost");
		builder.port(8182);
		builder.enableSsl(true);
		builder.keyCertChainFile("resources/aws/SFSRootCAG2.pem");

		Cluster cluster = builder.create();

//		GraphTraversalSource graph = traversal().withRemote(DriverRemoteConnection.using(cluster));
		final TinkerGraph graph = TinkerFactory.createGratefulDead();

		return graph.traversal();
	}
}
